grammar GenerativeSyntax

  rule base
    (set / ranges / group / array / pitch_classes / sleep / s / ignore)*
    {
    def value
      elements.map {|v| v.value }.flatten.filter_map {|v| ziff_to_string(v) if v}.join("")
    end
    }
  end

  rule set
    '{' ':'? content:(items) repeat_two:(':')? repeat:(integer)? '}' p:(('~' / '?') [1-9]*)? o:(operation)* inv:('_')? durs:(duration_set)?
    {
    def value

      reps = repeat.value if repeat.methods.include?(:value)
      reps = (reps and reps>1) ? reps : (repeat_two.text_value==":" ? 2 : 1)

      set = reps.times.collect do
        original_set = content.value.flatten.filter {|v| v != " "}
        set = Marshal.load(Marshal.dump(original_set))
        if p and p.text_value != ""
          set = set.shuffle if p.text_value[0]=="~"
          set = p.text_value[0]=="~" ? set.take(p.text_value[1..].to_i) : set.pick(p.text_value[1..].to_i) if p.text_value.length>1
        end

        if !o.empty? then
          o.elements.each do |op|
            if op.methods.include?(:value) then
              op_values = op.value.flatten.filter {|v| v and v != " "} if op.value.is_a?(Array)
              case op.operator
              when '**', '*', '/', '+', '-', '/', '^', '%', '|', '&', '<<', '>>'
                if op.value.kind_of?(Array)

                  if op.is_cartesian

                    set = op_values.map do |z|
                        set.map  do |c|
                            copy = Marshal.load(Marshal.dump(c))
                            copy[:pc] = z[:pc].method(op.operator).(c[:pc]) if z and c and z[:pc] and c[:pc]
                            copy
                        end
                      end
                    set = set.flatten

                  else

                  set = op_values.each_with_index.inject(set) do |a, (v,i)|
                    if v.is_a?(Hash) and a[i] and a[i].is_a?(Hash)
                      if v[:pc] and a[i][:pc]
                        a[i][:pc] = v[:pc].to_i.method(op.operator).(a[i][:pc].to_i)
                      elsif a[i][:pcs] and v[:pc]
                        a[i][:pcs][0] = a[i][:pcs][0].to_i.method(op.operator).(v[:pc].to_i)
                      elsif a[i][:pcs] and v[:pcs]
                        v[:pcs].each_with_index do |d,di|
                          a[i][:pcs][di] = a[i][:pcs][di].to_i.method(op.operator).(d.to_i)
                        end
                      elsif a[i][:pc] and v[:pcs]
                        a[i][:pcs] = v[:pcs]
                        a[i][:pcs][0] = a[i][:pcs][0].to_i.method(op.operator).(a[i][:pc].to_i)
                        a[i].delete(:pc)
                      end
                    end
                    a
                  end

                end

                else
                    operation_value = op.value.to_i
                    set = set.map do |v|
                      v[:pc] = v[:pc].to_i.method(op.operator).(operation_value) if v.is_a?(Hash)
                      v
                    end
                end
              end
            end
          end
        end
        set = set.map{|v| v[:pc] = ~(v[:pc].to_i-1) if v.is_a?(Hash) } if inv.text_value == '_'
        set.zip(Array.new(set.length-1," "))
      end
    set = set.zip(Array.new(reps," "))
    durations = durs.value if durs.methods.include?(:value)
    if durations and durations.is_a?(Array)
      set.flatten.map.with_index{|v,i| zlog v ; v[:sleep] = durations[i%durations.length] if v.is_a?(Hash) ; v  }
    else
      set
    end
    end
    }
  end

  rule duration_set
    '<' durs:(sleep / s)* '>'
    {
    def value
      durs.elements.map {|v| v.value }.filter_map {|v| v if v!=" "}
    end
    }
  end

  rule operation
    incremental:('@')? op:('**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '_') val:('-'? [0-9]+ / set / array / random_pitch_class_between)?
    {
    def is_cartesian
      (incremental and incremental.text_value == '@')
    end
    def operator
      op.text_value
    end
    def value
     if val.methods.include?(:value)
        v = val.value
        v
      else
        val.text_value
      end
    end
    }
  end

  rule array
    '[' first:(items) rest:(',' i:items)* ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        r.append(first.value).pick.flatten
      end
    end
    }
  end

  rule items
    (set / ranges / group / pitch_classes / s / sleep / array / random_pitch_classes_between)*
    {
    def value
      elements.map {|v| v.value }.filter_map {|v| v if v}
    end
    }
  end

  rule ranges
   a:(integer / random_pitch_class_between / integer_array) '..' b:(integer / random_pitch_class_between / integer_array) c:(step?)
   {
   def value
     s = a.value.to_i
     e = b.value.to_i
     ms = s>e ? e : s # 1..7
     me = e>s ? e : s # 7..1
     step = c.value if c.methods.include?(:value)
     nArr = (step ? (ms..me).step(step).to_a : (ms..me).to_a)
     nArr = nArr.reverse if s>e
     nArr.each_with_object([]){|v,o| o.push({pc: v}) ; o.push(" ") }
   end

   }
  end

  rule step
  '+' [0-9]+
  {
    def value
      text_value.to_i
    end
  }
  end

  rule ignore
   ([!~&@|{}<>:#-^_%\n] / [a-zA-Z1-9])
    {
      def value
        text_value
      end
    }
  end

  rule anything
    [\s\S]+
    {
      def value
        text_value
      end
    }
  end

  rule s
      [\s]+
      {
        def value
          text_value
        end
      }
  end

  rule group
   pitch_classes 2..
    {
     def value
     e = elements.collect {|v| v.value }
      if $parse_chords
        pitch_class_list = []
        e.each do |d|
          pitch_class_list.push(d[:pc])
        end
        v = {:pcs=>pitch_class_list}
        v
      else
        e.zip(Array.new(e.length-1," "))
      end
     end
    }
  end

  rule normal_pitch_class
    d:('-'? [0-9TE])
    {
      def value
        parse_str_dgr(d.text_value)
      end
    }
  end

  rule escaped_method
    '=(' e:(([a-zA-Z0-9] / '**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '!')*) ')'
    {
      def value
        eval(e.text_value)
      end
    }
  end

  rule escaped_pitch_class
    '=' e:('-'? [0-9]+)
    {
      def value
        e.text_value.to_i
      end
    }
  end

  rule random_pitch_class
    '?'
    {
      def value
        SonicPi::Core::SPRand.rand_i!(11)
      end
    }
  end

  rule integer
    '-'? [0-9]+
    {
      def value
        text_value.to_i
      end
    }
  end

  rule random_pitch_classes_between
    '(' between ' ' ')'
    {
      def value
        between.value.to_s.split("")
        #.map.with_index {|n,i| s[i%s.length]+n.to_s}
      end
    }
  end

  rule random_pitch_class_between
    '(' between ')'
    {
      def value
        between.value
      end
    }
  end

  rule between
    m:(integer / integer_array / random_pitch_class_between) ',' x:(integer / integer_array / random_pitch_class_between)
    {
      def value
        minv = m.value
        maxv = x.value
        return minv if minv == maxv
        range = (minv - maxv).abs
        r = SonicPi::Core::SPRand.rand_i!(range.to_i + 1)
        smallest = [minv, maxv].min
        (r + smallest)
      end
    }
  end

  rule integer_array
    '[' first:(integer / integer_array / random_pitch_class_between) rest:(',' i:(integer / integer_array / random_pitch_class_between))* ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        [r].append([first.value].flatten).flatten.pick(1)[0]
      end
    end
    }
  end

  rule pitch_classes
   z:(sleep)* o:('^' / '_')* a:('#' / 'b')* d:(normal_pitch_class / escaped_pitch_class / escaped_method / random_pitch_class / random_pitch_class_between)
    {
     def value
       dgr = d.value
       v = {:pc=>dgr}
       v[:add] = a.text_value if !a.text_value.empty?
       v[:octave] = o.text_value if !o.text_value.empty?
       v[:sleep] = z.text_value  if !z.text_value.empty?
       v
     end
    }
  end

  rule sleep
    [mklpdcwyhnqaefsxtgujz] ('.')*
    {
    def value
      text_value
    end
    }
  end

end
